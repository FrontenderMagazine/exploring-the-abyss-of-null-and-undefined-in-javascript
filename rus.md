# Исследование бездны null и undefined в JavaScript

Говоря о примитивных типах данных в JavaScript, большинство имеет в виду
основы: *String*, *Number*, and *Boolean*. Эти примитивы достаточно
предсказуемы и работают так, как это от них ожидется.
Однако, эта статья сосредоточится на менее обыденных примитивных типах,
*Null* и *Undefined*, на том, в чём они схожи, различны, и, вообще говоря,
необычны.

## Понимание null и undefined

В JavaScript `null` — это литерал и ключевое слово языка, которое представляет
собой отсутствие какого-либо объекта. Другими словами, `null` указывает
«в никуда». `undefined`, хоть и похож по смыслу, олицетворяет отсутствие
значения как такового.
Оба абсолюно неизменяемы, не имеют свойств и методов и не способны их иметь.
Фактически, попытка обратиться к какому-нибудь свойству, или присвоить его,
приведёт к ошибке `TypeError`. Оба этих примитива, как намекают их имена,
совершенно лишены значений.

Это самое отсутствие значения приводит к тому, что они считаются ложными, в
том смысле, что они приводятся к `false` если используются в качестве условия,
например, в конструкции `if`. А если сравнить `null` и `undefined` в другими
ложными значениями при помощи *оператора равенства* (`==`), то окажется, что
они не равны ничему, кроме самих себя:

    null == 0; // false
    undefined == ""; // false
    null == false; // false
    undefined == false; // false
    null == undefined; // true

Несмотря на эти сходства, `null` and `undefined` не эквивалентны. Каждый из
них является представителем своего типа: `undefined` — типа *Undefined*, а
`null` — типа *Null*. Это легко доказать, сравнив их при помощи *оператора
строгого равенства* (`===`), который принмает в расчёт не только значения,
но и типы:

    undefined === null; // false

Это важное различие, и оно не случайно, ведь эти примитивы служат для разных
целей. Чтобы их различать, вы можете считать `undefined` неожиданным
отсутствием значения, а `null` — умышленным отсутствием значения.

## Получение undefined

Есть множество способов получить значение `undefined` в коде. Обычно это
происходит при попытке получить значение там, где значения нет.
В этом случае JavaScript, будучи динамическим слаботипизированным языком,
не вызовет ошибки, а выдаст значение по умолчанию, `undefined`.

Любая объявленная переменная, которой при создании не присвоено никакого
значения, имеет значение `undefined`:

    var foo; // по умолчанию undefined

Значение `undefined` также получается при попытке обратиться к несуществующему
свойству объекту или элементу массива:

    var array = [1, 2, 3];
    var foo = array.foo; // свойство foo не существует, возвращается undefined
    var item = array[5]; // в массиве нет элемента 5, возвращается undefined

Если в функции нет оператора `return`, она возвращает `undefined`:

    var value = (function(){})(); // возвращает undefined

Если функции не был передан какой-либой аргумент, он становится `undefined`:

    (function(undefined){
        // параметр равен undefined
    })();

Таже для получения `undefined` может использоваться оператор `void`.
Библиотеки вроде [Underscore][1] пользуются этим для надежной проверки
типов, потому как `void` нельзя переопределить, и он всегда возвращет
`undefined`:

    function isUndefined(obj){
        return obj === void 0;
    }

Наконец, `undefined` — это предопределённая глобальная переменная (а не
ключевое слово, как `null`), которая равна `undefined`:

    'undefined' in window; // true

Начиная с пятой версии ECMAScript эта переменная доступна
[только для чтения][2], а, вот, в предыдущих версиях её было возможно
переопределить.

## Применение null

`null` отличается в первую очередь своим применением, в отличие от
`undefined`, `null` больше используется для присваивания значения. Как раз
из-за этого оператор `typeof` для `null` возвращает *«object»*. Изначально это
объяснялось тем, что `null` использовался (и используется) как пустая ссылка
там, где ожидается объект, что-то вроде заглушки. Такое поведение `typeof`
было позже признано багом, и хотя было [предложено][3] это поведение
исправить, пока что в целях обратной совместимости всё остается как есть.

Вот, почему окружение JavaScript не выставляет никаких значений в `null`, и
это делается только программно. В [документации на MDN][4] написано:

> В различных API `null` часто возвращается в тех местах, где ожидается
> объект, но такой объект подобрать нельзя.

Это правда для DOM, который не зависит от языка и никак не описывается в
документации ECMAScript. Из-за того, что используется внешний API, попытка
получить отсутствующий элемент возвращает `null`, а не `undefined`.

Вообще, если нужно присвоить «не-значение» переменной или свойству,
передать его в функцию, или вернуть из функции, то `null` — это почти всегда
лучший вариант. Упрощённо: JavaScript использует `undefined`, а программисты
*должны* использовать `null`.

Другой способ применения `null` — явное «зануливание» переменной
(`object = null`) когда ссылка на объект больше не требуется. Кстати, это
считается хорошей практикой. Присваивая `null`, вы фактически удаляете ссылку
на объект, и если на него нет других ссылок, он отправляется к сборщику
мусора, таким образом возвращая доступную память.

## Копнём глубже

Причина того, что `null` и `undefined` эдакие чёрные дыры, кроется не только в
их поведении, но ещё и в том, как они обрабатываются внутри окружения
JavaScript. Они не обладают теми характеристиками, которые обычно присущи
другим примитивам и встроенным объектам.

Начиная с ES5 метод `Object.prototype.toString`, ставший стандартом де-факто
для проверки типов, стал полезен в этом отношении и для `null` с `undefined`:

    Object.prototype.toString.call(null); // [object Null]
    Object.prototype.toString.call(undefined); // [object Undefined]

Однако, на самом деле у `null` и `undefined` этот метод не возвращает
внутреннее свойство `[[Class]]`. По [документации][5] он работает следующим
образом:

> 1.  Если значение `this` равно `undefined`, вернуть `"[object Undefined]"`.
> 2.  Если значение `this` равно `null`, вернуть `"[object Null]"`.
> 3.  Пусть O равно результату вызова `ToObject` с `this`, переданным как
>     аргумент.
> 4.  Пусть class равно внутреннему свойству `[[Class]]` объекта O.
> 5.  Вернуть значение String, которое является результатом сложения трёх
>     строк
>    `"[object "`, class, и `"]"`.

Этот метод просто возвращает заготовленную строку, если обнаруживает `null`
или `undefined` просто чтобы унифицировать функциональность с другими
объектами.
Такое поведение встречается сплошь и рядом во всей документации, большая часть
методов содержат простую проверку, и если встретился `null` или `undefined`,
возвращают значение сразу. Фактически, нигде не написано, что у них содержатся
какие-либо [внутренние свойства][6], обычно имеющиеся у каждого нативного
объекта. Это как если бы они вообще не были объектами? Интересно, эти
примитивы в окружении JavaScript как-то явно и особо обрабатываются?
Может быть, кто-то более знакомый с имплементацией мог бы подсказать.

## Заключение

Неважно, насколько необычными кажутся эти примитивы, понимание `null` и
`undefined`, разницы между ними и их различных ролей в JavaScript
очень важно для понимания языка. Это понимание само по себе не заставит
работать ваше приложение и не сломает его, но вообще говоря, оно положительно
скажется в долгосрочной перспективе, облегчая разработку и отладку.

---

## Комментарий переводчика

При описании автор забыл упомянуть одну важную деталь: у примитивов как
таковых свойств быть не может, они есть только у объектов.
А при попытке получить свойство у примитива он неявно преобразуется в объект.
В этом легко убедиться:

    var s = 'test', o = Object(s);
    o.foo = 42;
    s.foo = 42;
    o.foo; // 42
    s.foo; // undefined

`null` и `undefined` [нельзя преобразовать][-translator-1] в объект, этим и
объясняется их особенность.

Также, фраза про то, что `null` в окружении JavaScript без явного присваивания
не используется, неверна. В конце цепочки прототипов находится `null`, и это
как раз тот случай, когда ожидается объект, но его нет:

    Object.getPrototypeOf(Object.prototype); // null

 [1]: https://github.com/jashkenas/underscore/blob/master/underscore.js#L1052
 [2]: http://es5.github.io/#x15.1.1.3
 [3]: http://wiki.ecmascript.org/doku.php?id=proposals:typeof
 [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null
 [5]: http://es5.github.io/#x15.2.4.2
 [6]: http://es5.github.io/#x8.6.2

 [-translator-1]: http://es5.github.io/#x9.9